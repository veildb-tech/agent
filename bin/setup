#!/bin/sh

export PROJECT_ROOT
PROJECT_ROOT="$(dirname "$(realpath $0)")/"
USE_DOCKER=0
MANAGER_CLI="${PROJECT_ROOT}dbvisor-agent"

command_exists() {
    if [ "$@" = "docker compose" ] ; then
        docker compose version > /dev/null 2>&1
    else
        command -v "$@" > /dev/null 2>&1
    fi
}

user="$(id -un 2>/dev/null || true)"
sh_c='su -c'
if [ "$user" != 'root' ]; then
    if command_exists sudo; then
        sh_c='sudo -E sh -c'
    elif command_exists su; then
        sh_c='su -c'
    else
        echo
        echo "Error: this installer needs the ability to run commands as root."
        echo "We are unable to find either 'sudo' or 'su' available to make this happen."
        echo
        exit 1
    fi
fi

_output() {
    style_start=""
    style_end=""
    if [ "${2:-}" != "" ]; then
        case $2 in
            "success")
                style_start="\033[0;32m"
                style_end="\033[0m"
                ;;
            "error")
                style_start="\033[31;31m"
                style_end="\033[0m"
                ;;
            "info"|"warning")
                style_start="\033[33m"
                style_end="\033[39m"
                ;;
            "heading")
                style_start="\033[1;33m"
                style_end="\033[22;39m"
                ;;
            "comment")
                style_start="\033[2m"
                style_end="\033[22;39m"
                ;;
        esac
    fi

    printf "${style_start}${1}${style_end}\n"
}

# Validate is docker installed
# Install in case required
_installDocker() {
    if ! command_exists docker ; then
        read -r -p "The docker tool is not found. Do you want to install it? (Y/n) " yn </dev/tty
        if [ $(expr match "${yn}" '[Nn]') != 0 ]; then
            echo "Installation process stopped...";
            exit
        else
            "${PROJECT_ROOT}"bin/docker/install_docker.sh
        fi
    fi

    DOCKER_COMPOSE_EXISTS="True"
    if ! command_exists "docker compose" ; then
        if ! command_exists "docker-compose" ; then
            DOCKER_COMPOSE_EXISTS="False"
        fi
    fi

    if [ $DOCKER_COMPOSE_EXISTS = "False" ] ; then
        read -r -p "The docker compose plugin is not found. Do you want to install it? (Y/n) " yn </dev/tty
        if [ $(expr match "${yn}" '[Nn]') != 0 ]; then
            echo "Installation process stopped...";
            exit
        else
            "${PROJECT_ROOT}"bin/docker/install_docker.sh
        fi
    fi

    if [ ! -f /.dockerenv  ]; then
        if [ "${USER}" != 'root' ] && [ -e "/var/run/docker.sock" ]; then
            $sh_c "usermod -aG docker ${USER}"
            $sh_c "chown root:docker /var/run/docker.sock"
            $sh_c "chmod -R 777 /var/run/docker.sock"
        fi

        if ! docker run --rm hello-world; then
            _output "  ERROR: Could not get docker to run the hello world container" "error"
            exit 2
        fi
    fi
}

# Check docker ports
_checkDockerPorts() {
    if lsof -i -P -n | grep LISTEN | grep :80
    then
        _output "  [ ] ERROR: The port 80 is already used by another service" "error"
    fi

    if lsof -i -P -n | grep LISTEN | grep :443
    then
        _output "  [ ] ERROR: The port 443 is already used by another service" "error"
    fi
}

# Check docker libs for docker
_checkDockerRequiredLibs() {
    _output " Start checking required applications: " "heading"

    if command -v lsof >/dev/null 2>&1; then
        _output "  [*] Lsof is installed" "success"
    else
        _output "  [ ] ERROR: Lsof is required for installation." "error"
        exit 1
    fi

    if command -v curl >/dev/null 2>&1; then
        _output "  [*] Curl is installed" "success"
    else
        _output "  [ ] ERROR: Curl is required for installation" "error"
        exit 1
    fi

    if command -v zip >/dev/null 2>&1; then
        _output "  [*] Zip is installed" "success"
    else
        _output "  [ ] ERROR: Zip is required for installation" "error"
        exit 1
    fi
}

# Check is all required applications are installed
_checkRequiredLibs() {
    _output " Start checking required applications: " "heading"

    if command -v composer >/dev/null 2>&1; then
        _output "  [*] Composer is installed" "success"
    else
        _output "  [ ] ERROR: Composer is required for installation" "error"
        exit 1
    fi

    if command -v php >/dev/null 2>&1; then
        _output "  [*] PHP is installed" "success"
    else
        _output "  [ ] ERROR: PHP is required for installation" "error"
        exit 1
    fi

    if [ "$(php -m | grep -c ssh2)" != "0" ]; then
        _output "  [*] PHP Extension ext-ssh2 is installed" "success"
    else
        _output "  [ ] ERROR: PHP Extension ext-ssh2 is required for installation" "error"
        exit 1
    fi

    if [ "$(php -m | grep -c dom)" != "0" ]; then
        _output "  [*] PHP Extension ext-xml is installed" "success"
    else
        _output "  [ ] ERROR: PHP Extension ext-xml is required for installation" "error"
        exit 1
    fi

    if [ "$(php -m | grep -c pdo)" != "0" ]; then
        _output "  [*] PHP Extension php-mysql is installed" "success"
    else
        _output "  [ ] ERROR: PHP Extension php-mysql is required for installation" "error"
        exit 1
    fi

    if command -v zip >/dev/null 2>&1; then
        _output "  [*] Zip is installed" "success"
    else
        _output "  [ ] ERROR: Zip is required for installation" "error"
        exit 1
    fi

    if command -v curl >/dev/null 2>&1; then
        _output "  [*] Curl is installed" "success"
    else
        _output "  [ ] ERROR: Curl is required for installation" "error"
        exit 1
    fi
}

# Get Client IP
_getClientIP() {
    curl -s ifconfig.me
}

# Replace Function
_replace_pattern() {
    FROM=$1
    TO=$2
    FILE=$3

    if [ "$(uname)" != "Darwin" ]; then
        sed -i "s|${FROM}|${TO}|g" ${FILE}
    else
        LC_ALL=C sed -i '' "s|${FROM}|${TO}|g" ${FILE}
    fi
}

# Generate JWT secret key
_generateJwtKey() {
    jwt_secret=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 43)

    echo "$jwt_secret"
}

# Init global command alias
_initAlias() {
    NAME="dbvisor-agent"
    DEFINITION="${MANAGER_CLI}"

    if [ -f ${HOME}/.bash_aliases ] && [ $(which bash) != "" ]; then
        if [ "$(cat < "${HOME}/.bash_aliases" | grep -c "${NAME}")" = "0" ] ; then
            echo "alias $NAME='$DEFINITION'" >> ${HOME}/.bash_aliases

            source ${HOME}/.bash_aliases
            source ${HOME}/.bashrc

            exec bash --login
        fi
    fi

    if [ -f ${HOME}/.zshrc ] && [ $(which zsh) != "" ]; then
        if [ "$(cat < "${HOME}/.zshrc" | grep -c "${NAME}")" = "0" ] ; then
            echo "alias $NAME='$DEFINITION'" >> ${HOME}/.zshrc

            source ${HOME}/.zshrc
        fi
    fi

    if [ -f ${HOME}/.bashrc ] && [ $(which bash) != "" ]; then
        if [ "$(cat < "${HOME}/.bashrc" | grep -c "${NAME}")" = "0" ] ; then
            echo "alias $NAME='$DEFINITION'" >> ${HOME}/.bashrc

            source ${HOME}/.bashrc

            exec bash --login
        fi
    fi

    if [ $(which sh) != "" ]; then
        if [ ! -f ${HOME}/.profile ]; then
            touch ${HOME}/.profile
        fi

        if [ "$(cat < "${HOME}/.profile" | grep -c "${NAME}")" = "0" ] ; then
            echo "alias $NAME='$DEFINITION'" >> ${HOME}/.profile

            source ${HOME}/.profile

            exec sh --login
        fi
    fi
}

# Fix possible issues with directory
_fixDirectory() {
    DIRECTORY=${1}
    STR_LEN=$(echo ${DIRECTORY} | wc -c)

    if [ "$(echo "${DIRECTORY}" | cut -b 1)" != "/" ]; then
        DIRECTORY="/${DIRECTORY}"
    fi

    if [ "$(echo "${DIRECTORY}" | cut -c$(expr $STR_LEN - 1)-${STR_LEN})" != "/" ]; then
        DIRECTORY="${DIRECTORY}/"
    fi

    echo "${DIRECTORY}"
}

_output " Started Project setting " "heading"

# Validate environment.
read -r -p " Do you want to use a docker? (Y/n) " yn </dev/tty
if [ $(expr match "${yn}" '[Nn]') != 0 ]; then
    USE_DOCKER=0
    _checkRequiredLibs
    "${PROJECT_ROOT}"bin/docker/install_tools.sh
else
    USE_DOCKER=1
    _checkDockerRequiredLibs
    _checkDockerPorts
    _installDocker
fi

# Init configurations:
 _output " Initializing Base configurations " "heading"

if [ ! -f "${PROJECT_ROOT}.env" ]; then
    cp "${PROJECT_ROOT}env-sample" "${PROJECT_ROOT}.env"
fi

# Get project configurations
export $(cat "${PROJECT_ROOT}.env" | grep -v ^# | grep -v ^alias | xargs)

if [ "${APP_DOCKER_USE}" != "${USE_DOCKER}" ]; then
    _replace_pattern "APP_DOCKER_USE=${APP_DOCKER_USE}" "APP_DOCKER_USE=${USE_DOCKER}" ${PROJECT_ROOT}/.env
fi

# Get Server URL
if [ "${USE_DOCKER}" = "1" ]; then
    CLIENT_IP=$(_getClientIP)
    if [ ! -z "${APP_DOCKER_SERVER_URL}" ]; then
        DEFAULT_SERVER_PORT=${APP_DOCKER_SERVER_URL}:${APP_DOCKER_HTTP_PORT}
    else
        DEFAULT_SERVER_PORT=${CLIENT_IP}:${APP_DOCKER_HTTP_PORT}
    fi

    read -rp " Enter the host name for the current Server ( default: ${DEFAULT_SERVER_PORT} ): " NEW_APP_DOCKER_SERVER_URL </dev/tty
    if [ "${NEW_APP_DOCKER_SERVER_URL}" != "${DEFAULT_SERVER_PORT}" ]; then
        if [ -z "${NEW_APP_DOCKER_SERVER_URL}" ]; then
            NEW_APP_DOCKER_SERVER_URL="${DEFAULT_SERVER_PORT}"
        fi

        OLD_IFS=$IFS
        IFS=':'
        set -- ${NEW_APP_DOCKER_SERVER_URL}
        IFS=$OLD_IFS

        URL=${1}
        PORT=${2}

        _replace_pattern "APP_DOCKER_SERVER_URL=${APP_DOCKER_SERVER_URL}" "APP_DOCKER_SERVER_URL=${URL:=${CLIENT_IP}}" ${PROJECT_ROOT}/.env
        _replace_pattern "APP_DOCKER_HTTPS_PORT=${APP_DOCKER_HTTPS_PORT}" "APP_DOCKER_HTTPS_PORT=${PORT:=${APP_DOCKER_HTTPS_PORT}}" ${PROJECT_ROOT}/.env
        _replace_pattern "APP_DOCKER_HTTP3_PORT=${APP_DOCKER_HTTPS_PORT}" "APP_DOCKER_HTTP3_PORT=${PORT:=${APP_DOCKER_HTTPS_PORT}}" ${PROJECT_ROOT}/.env
    fi
fi

DEFAULT_APP_DUMP_PATH="${HOME}/${APP_NAME}-backups/"
if [ ! -z ${APP_DUMP_PATH} ] && [ "${USE_DOCKER}" = "0" ]; then
    DEFAULT_APP_DUMP_PATH="${APP_DUMP_PATH%/backups}/"
fi

if [ ! -z ${APP_DOCKER_PATH_DUMP} ] && [ "${USE_DOCKER}" = "1" ]; then
    DEFAULT_APP_DUMP_PATH="${APP_DOCKER_PATH_DUMP%/backups}/"
fi

# Get path to dumps folder
NEW_APP_DUMP_PATH=""
while [ "${NEW_APP_DUMP_PATH}" = "" ] || [ "$(expr match "${NEW_APP_DUMP_PATH}" '~')" != "0" ]; do
    read -rp " Enter the full path to folder where processed dumps will be placed (default: ${DEFAULT_APP_DUMP_PATH} ): " NEW_APP_DUMP_PATH </dev/tty
    NEW_APP_DUMP_PATH=${NEW_APP_DUMP_PATH:="${DEFAULT_APP_DUMP_PATH}"}
    NEW_APP_DUMP_PATH=$(_fixDirectory "${NEW_APP_DUMP_PATH}")
done

if [ "${USE_DOCKER}" = "1" ]; then
    _replace_pattern "APP_DOCKER_PATH_DUMP='${APP_DOCKER_PATH_DUMP}'" "APP_DOCKER_PATH_DUMP='${NEW_APP_DUMP_PATH}backups'" ${PROJECT_ROOT}.env
    _replace_pattern "APP_DOCKER_PATH_CONFIG='${APP_DOCKER_PATH_CONFIG}'" "APP_DOCKER_PATH_CONFIG='${NEW_APP_DUMP_PATH}configs'" ${PROJECT_ROOT}.env
else
    _replace_pattern "APP_DUMP_PATH='${APP_DUMP_PATH}'" "APP_DUMP_PATH='${NEW_APP_DUMP_PATH}backups'" ${PROJECT_ROOT}.env
    _replace_pattern "APP_CONFIG_PATH='${APP_CONFIG_PATH}'" "APP_CONFIG_PATH='${NEW_APP_DUMP_PATH}configs'" ${PROJECT_ROOT}.env
fi

if [ ${USE_DOCKER} = "1" ]; then
    DEFAULT_APP_DUMP_PATH="${HOME}/${APP_NAME}-backups/local_backups"
    if [ ! -z "${APP_DOCKER_LOCAL_BACKUPS_PATH}" ]; then
        DEFAULT_APP_DUMP_PATH=${APP_DOCKER_LOCAL_BACKUPS_PATH}
    fi

    read -r -p " Do you have locally placed backups, or do you plan to use manual backups in future? (Y/n) " yn </dev/tty
    if [ "$(expr match "${yn}" '[Nn]')" != "0" ]; then
        NEW_APP_DOCKER_LOCAL_BACKUPS_PATH=${DEFAULT_APP_DUMP_PATH}
    else
        NEW_APP_DOCKER_LOCAL_BACKUPS_PATH=""
        while [ "${NEW_APP_DOCKER_LOCAL_BACKUPS_PATH}" = "" ] || [ "$(expr match "${NEW_APP_DOCKER_LOCAL_BACKUPS_PATH}" '~')" != "0" ]; do
            read -rp " Enter the full path to folder with your local dumps (default: ${DEFAULT_APP_DUMP_PATH} ): " NEW_APP_DOCKER_LOCAL_BACKUPS_PATH </dev/tty
            NEW_APP_DOCKER_LOCAL_BACKUPS_PATH=${NEW_APP_DOCKER_LOCAL_BACKUPS_PATH:="${DEFAULT_APP_DUMP_PATH}"}
            NEW_APP_DOCKER_LOCAL_BACKUPS_PATH=$(_fixDirectory "${NEW_APP_DOCKER_LOCAL_BACKUPS_PATH}")
        done
    fi
    _replace_pattern "APP_DOCKER_LOCAL_BACKUPS_PATH='${APP_DOCKER_LOCAL_BACKUPS_PATH}'" "APP_DOCKER_LOCAL_BACKUPS_PATH='${NEW_APP_DOCKER_LOCAL_BACKUPS_PATH}'" ${PROJECT_ROOT}.env
fi

if [ -z "${APP_SECRET}" ]; then
    # Generate APP secret
    _replace_pattern "APP_SECRET=" "APP_SECRET=$(_generateJwtKey)" ${PROJECT_ROOT}/.env
fi

if [ -z "${SECRET_KEY_PRIVATE}" ]; then
    if [ ${USE_DOCKER} = "1" ]; then
        _replace_pattern "SECRET_KEY_PRIVATE=" "SECRET_KEY_PRIVATE=/app/config/keys/private" ${PROJECT_ROOT}.env
    else
        _replace_pattern "SECRET_KEY_PRIVATE=" "SECRET_KEY_PRIVATE=${PROJECT_ROOT}/config/keys/private" ${PROJECT_ROOT}.env
    fi
fi

if [ -z "${SECRET_KEY_PUBLIC}" ]; then
    if [ ${USE_DOCKER} = "1" ]; then
        _replace_pattern "SECRET_KEY_PUBLIC=" "SECRET_KEY_PUBLIC=/app/config/keys/public" ${PROJECT_ROOT}.env
    else
        _replace_pattern "SECRET_KEY_PUBLIC=" "SECRET_KEY_PUBLIC=${PROJECT_ROOT}/config/keys/public" ${PROJECT_ROOT}.env
    fi
fi

# Select engines:
_output " Initializing supported DB engines " "heading"

while true; do
    echo "1. MySQL"
    echo "2. MariaDB"
    echo "3. Postgres"
    echo "4. Continue"

    read -p "Choose DB engines which will be used: " choice
    case $choice in
        1)
            if [ ! -f ${PROJECT_ROOT}.env.mysql ]; then
                cp ${PROJECT_ROOT}env.mysql-sample ${PROJECT_ROOT}.env.mysql
            fi
            echo "MySQL Selected."
            ;;
        2)
            if [ ! -f {PROJECT_ROOT}.env.mariadb ]; then
                cp ${PROJECT_ROOT}env.mariadb-sample ${PROJECT_ROOT}.env.mariadb
            fi
            echo "MariaDB Selected."
            ;;
        3)
            if [ ! -f {PROJECT_ROOT}.env.pgsql ]; then
                cp ${PROJECT_ROOT}env.pgsql-sample ${PROJECT_ROOT}.env.pgsql
            fi
            echo "Postgres Selected."
            ;;
        4)
            break
            ;;
        *)
            echo "Invalid option. Try again."
            ;;
    esac
done </dev/tty

# Select DB Version
if [ -f ${PROJECT_ROOT}.env.mariadb ]; then
    while true; do
        echo "1. 10.4"
        echo "2. 10.5"
        echo "3. 10.6"
        echo "4. 10.11"
        echo "5. 11.0"
        echo "6. 11.1"
        echo "7. 11.3"
        echo "8. 11.4"
        echo "9. latest"

        read -p "Choose MariaDB version ( default is latest ): " choice
        case $choice in
            1)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=10.4" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            2)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=10.5" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            3)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=10.6" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            4)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=10.11" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            5)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=11.0" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            6)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=11.1" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            7)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=11.3" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            8)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=11.4" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
            ''|9)
                _replace_pattern "MARIA_DB_VERSION=[a-z0-9.]*" "MARIA_DB_VERSION=latest" ${PROJECT_ROOT}.env.mariadb
                break
                ;;
        esac
    done </dev/tty
fi

if [ -f ${PROJECT_ROOT}.env.mysql ]; then
    while true; do
        echo "1. 5.5"
        echo "2. 5.6"
        echo "3. 5.7"
        echo "4. 8.0"
        echo "5. 8.1"
        echo "6. 8.2"
        echo "7. 8.3"
        echo "8. latest"

        read -p "Choose MySQL DB version ( default is latest ): " choice
        case $choice in
            1)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=5.5" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            2)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=5.6" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            3)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=5.7" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            4)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=8.0" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            5)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=8.1" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            6)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=8.2" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            7)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=8.3" ${PROJECT_ROOT}.env.mysql
                break
                ;;
            ''|8)
                _replace_pattern "MYSQL_DB_VERSION=[a-z0-9.]*" "MYSQL_DB_VERSION=latest" ${PROJECT_ROOT}.env.mysql
                break
                ;;
        esac
    done </dev/tty
fi

if [ -f ${PROJECT_ROOT}.env.pgsql ]; then
    while true; do
        echo "1. 12"
        echo "2. 13"
        echo "3. 14"
        echo "4. 15"
        echo "5. 16"
        echo "6. latest"

        read -p "Choose Postgres DB version ( default is latest ): " choice
        case $choice in
            1)
                _replace_pattern "POSTGRES_DB_VERSION=[a-z0-9.]*" "POSTGRES_DB_VERSION=12" ${PROJECT_ROOT}.env.pgsql
                break
                ;;
            2)
                _replace_pattern "POSTGRES_DB_VERSION=[a-z0-9.]*" "POSTGRES_DB_VERSION=13" ${PROJECT_ROOT}.env.pgsql
                break
                ;;
            3)
                _replace_pattern "POSTGRES_DB_VERSION=[a-z0-9.]*" "POSTGRES_DB_VERSION=14" ${PROJECT_ROOT}.env.pgsql
                break
                ;;
            4)
                _replace_pattern "POSTGRES_DB_VERSION=[a-z0-9.]*" "POSTGRES_DB_VERSION=15" ${PROJECT_ROOT}.env.pgsql
                break
                ;;
            5)
                _replace_pattern "POSTGRES_DB_VERSION=[a-z0-9.]*" "POSTGRES_DB_VERSION=16" ${PROJECT_ROOT}.env.pgsql
                break
                ;;
            ''|6)
                _replace_pattern "POSTGRES_DB_VERSION=[a-z0-9.]*" "POSTGRES_DB_VERSION=latest" ${PROJECT_ROOT}.env.pgsql
                break
                ;;
        esac
    done </dev/tty
fi

# Get project configurations
export $(cat "${PROJECT_ROOT}.env" | grep -v ^# | grep -v ^alias | xargs)

# Validate and create all folders and sub-folders
if [ ! -d "${NEW_APP_DUMP_PATH}backups" ]; then
    mkdir -p "${NEW_APP_DUMP_PATH}backups" "${NEW_APP_DUMP_PATH}backups/processed" "${NEW_APP_DUMP_PATH}backups/untouched"
fi

if [ ! -d "${NEW_APP_DUMP_PATH}configs" ]; then
    mkdir -p "${NEW_APP_DUMP_PATH}configs"
fi

if [ "${USE_DOCKER}" = "1" ]; then
    if [ ! -d "${APP_DOCKER_LOCAL_BACKUPS_PATH}" ]; then
        mkdir -p "${APP_DOCKER_LOCAL_BACKUPS_PATH}"
    fi
fi

if [ ! -z "${APP_DOCKER_SERVER_URL}" ] && [ -z $(grep -c ${APP_DOCKER_SERVER_URL} /etc/hosts) ]; then
    if [ "$user" != 'root' ]; then
        _output " Your system password has been requested to add an entry to /etc/hosts... " "info"
    fi
    $sh_c echo "127.0.0.1 ::1 ${APP_DOCKER_SERVER_URL}" >> /etc/hosts
fi

if [ "${USE_DOCKER}" = "1" ]; then
    _output " Starting Docker containers " "heading"

    "${PROJECT_ROOT}"bin/docker/start -b
else
    if [ -z "$(ls -A "${PROJECT_ROOT}/vendor/" 2>/dev/null)" ]; then
        composer install --working-dir="${PROJECT_ROOT}" --prefer-dist --no-progress --no-interaction
    fi
fi

_initAlias

# Generate Server key pair
( sleep 5; "${PROJECT_ROOT}"dbvisor-agent app:server:generate-keypair --identifier='server' --key-only > /dev/null 2>&1 )

_output " The dbvisor agent had been installed successfully. " "info"
"${PROJECT_ROOT}"dbvisor-agent info
if [ -z "${APP_SERVER_UUID}" ]; then
    _output " To continue please execute the command: ${MANAGER_CLI} app:server:add " "warning"
fi